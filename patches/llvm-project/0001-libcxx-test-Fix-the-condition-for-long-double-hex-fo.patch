From d3e765ef3da9a100b362e3b3d49c97a07b270083 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Martin=20Storsj=C3=B6?= <martin@martin.st>
Date: Wed, 12 Mar 2025 22:44:09 +0200
Subject: [PATCH 1/2] [libcxx] [test] Fix the condition for long double hex
 formatting

This test currently hardcodes which environments have got 80 bit
long doubles on x86_64; add a check for the actual size of
the long doubles as well. This allows waiving this test for
x86_64 configurations with a different size of long doubles.
---
 .../facet.num.put.members/put_long_double.hex.pass.cpp       | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/libcxx/test/std/localization/locale.categories/category.numeric/locale.nm.put/facet.num.put.members/put_long_double.hex.pass.cpp b/libcxx/test/std/localization/locale.categories/category.numeric/locale.nm.put/facet.num.put.members/put_long_double.hex.pass.cpp
index ee7382e23c8c..5905a5ad9e46 100644
--- a/libcxx/test/std/localization/locale.categories/category.numeric/locale.nm.put/facet.num.put.members/put_long_double.hex.pass.cpp
+++ b/libcxx/test/std/localization/locale.categories/category.numeric/locale.nm.put/facet.num.put.members/put_long_double.hex.pass.cpp
@@ -1853,11 +1853,10 @@ void test2()
 {
     std::locale lc = std::locale::classic();
     std::locale lg(lc, new my_numpunct);
-#if (defined(__APPLE__) || defined(TEST_HAS_GLIBC) || defined(__MINGW32__)) && defined(__x86_64__)
+#if (defined(__APPLE__) || defined(TEST_HAS_GLIBC) || defined(__MINGW32__)) && defined(__x86_64__) && __LDBL_MANT_DIG__ == 64
 // This test is failing on FreeBSD, possibly due to different representations
 // of the floating point numbers.
-// This test is failing in MSVC environments, where long double is equal to regular
-// double, and instead of "0x9.32c05a44p+27", this prints "0x1.26580b4880000p+30".
+// This test assumes that long doubles are x87 80 bit long doubles.
     const my_facet f(1);
     char str[200];
     {
-- 
2.43.0

